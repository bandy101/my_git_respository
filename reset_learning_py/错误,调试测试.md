#try-except                 finally
            Exception as e:
                print(e)
#记录错误：
    import logging or import traceback.print_exc()
        /*logging.exception(e)*/
            打印错误信息会继续执行下面语句不会停止
#单步调试->n p+var-> 查看变量
    import pdb，然后，在可能出错的地方放一个pdb.set_trace()，就可以设置一个断点
    程序会自动在pdb.set_trace()暂停并进入pdb调试环境，可以用命令p查看变量，或者用命令c继续运行

#单元测试 TDD （Test-Driven-Development)
    ▲单元测试是用来对一个模块、一个函数或者一个类来进行正确性检验的测试工作。
    ▲单元测试通过后有什么意义呢？如果我们对abs()函数代码做了修改，只需要再跑一遍单元测试，如果通过，说明我们的修改不会对abs()函数原有的行为造成影响，如果测试不通过，说明我们的修改与原有行为不一致，要么修改代码，要么修改测试。
    ▲这种以测试为驱动的开发模式最大的好处就是确保一个程序模块的行为符合我们设计的测试用例。在将来修改的时候，可以极大程度地保证该模块行为仍然是正确的。
    from mydict import Dict
    class TestDict(unittest.TestCase):
        def test_init(self):
            d = Dict(a=1, b='test')
            self.assertEqual(d.a, 1)
            self.assertEqual(d.b, 'test')
            self.assertTrue(isinstance(d, dict))
        def test_key(self):
            d = Dict()
            d['key'] = 'value'
            self.assertEqual(d.key, 'value')
        def test_attr(self):
            d = Dict()
            d.key = 'value'
            self.assertTrue('key' in d)
            self.assertEqual(d['key'], 'value')
        def test_keyerror(self):
            d = Dict()
            with self.assertRaises(KeyError):
                value = d['empty']
        def test_attrerror(self):
            d = Dict()
            with self.assertRaises(AttributeError):
                value = d.empty